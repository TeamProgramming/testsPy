#!/usr/bin/python3 -O
# -*- coding: utf-8 -*-
import time
import sys
import getopt
import threading
import os
import multiprocessing

import requests

def pa(i):
    url = 'http://qilt.co.za/d3/svg/'
    r = requests.get(url+"150315"+str(i)+".svg")
    if r.status_code != 404:
        print("150315"+str(i)+".svg")
        with open("150315"+str(i)+".svg", 'wb') as output_file:
            output_file.write(r.text.encode('cp1251'))
def ncount( n ) : # тестовая CPU-загружающая функция
    print( str(6000+200*n)+" - "+str(6000+200*(n+1))+"\n")
    n=0
    for i in range(6000+200*n,6000+200*(n+1)): pa(i)
    print("nn = "+str(n)+"\n")

if __name__ == '__main__':

    thrnum = 5
    mode = 't' # варианты запуска

    try :
        opts, args = getopt.getopt( sys.argv[1:], "t:n:m:" )
    except getopt.GetoptError :
        print ( "недопустимая опция команды или её значение" )
    
    for opt, arg in opts :
        if opt[ 1: ] == 't' : thrnum = int( arg )

    print( "число процессоров (ядер) = {0:d}".format( multiprocessing.cpu_count() ) )
    print( "исполнение в Python версия {0:s}".format( sys.version ) )
    print( "число ветвей выполнения {0:d}".format( thrnum ) )
    if 't' in mode :
        print( "================ параллельные потоки ================" )
        threads = []
        for n in range( thrnum ) :
            tid = threading.Thread( target = ncount, args=( n, ) ) #!!!
            threads.append( tid )
            tid.setDaemon( 1 )
        clc = time.time()
        for n in range( thrnum ) : threads[ n ].start()
        for n in range( thrnum ) : threads[ n ].join()
        clc = time.time() - clc
        print( "время {0:.2f} секунд".format( clc ) )
    if 'p' in mode :
        print( "=============== параллельные процессы ===============" )
        threads = []; fork = True
        clc = time.time()
        for n in range( thrnum ) :
            try : pid = os.fork();
            except :
                print( "ошибка создания дочернего процесса" )
                fork = False
                break
            else :
                if pid == 0 : # дочерний процесс
                    ncount( repnum )
                    sys.exit( 0 )
                if pid > 0 :  # родительский процесс
                    threads.append( pid )
        if fork :
            for p in threads :
                pid, status = os.wait()
            clc = time.time() - clc
            print( "время {0:.2f} секунд".format( clc ) )

    if 'm' in mode :
        print( "=============== модуль multiprocessing ==============" )
        parms = []
        for n in range( thrnum ) :
            parms.append( repnum )
        multiprocessing.freeze_support()
        pool = multiprocessing.Pool( processes = thrnum, )
        clc = time.time()
        pool.map( ncount, parms )
        clc = time.time() - clc
        print( "время {0:.2f} секунд".format( clc ) )
